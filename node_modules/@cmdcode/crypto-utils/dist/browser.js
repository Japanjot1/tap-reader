var crypto_utils=function(t){"use strict";function e(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function r(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}const n={number:e,bool:function(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)},bytes:r,hash:function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");e(t.outputLen),e(t.blockLen)},exists:function(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")},output:function(t,e){r(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}};var i=n;const o="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,s=t=>t instanceof Uint8Array,f=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),a=(t,e)=>t<<32-e|t>>>e;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function c(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!s(t))throw new Error("expected Uint8Array, got "+typeof t);return t}Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));let h=class{clone(){return this._cloneInto()}};function u(t){const e=e=>t().update(c(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function d(t=32){if(o&&"function"==typeof o.getRandomValues)return o.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}let l=class extends h{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=f(this.buffer)}update(t){i.exists(this);const{view:e,buffer:r,blockLen:n}=this,o=(t=c(t)).length;for(let i=0;i<o;){const s=Math.min(n-this.pos,o-i);if(s!==n)r.set(t.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===n&&(this.process(e,0),this.pos=0);else{const e=f(t);for(;n<=o-i;i+=n)this.process(e,i)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){i.exists(this),i.output(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:o}=this;let{pos:s}=this;e[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>n-s&&(this.process(r,0),s=0);for(let t=s;t<n;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),f=Number(r&o),a=n?4:0,c=n?0:4;t.setUint32(e+a,s,n),t.setUint32(e+c,f,n)}(r,n-8,BigInt(8*this.length),o),this.process(r,0);const a=f(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=c/4,u=this.get();if(h>u.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<h;t++)a.setUint32(4*t,u[t],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return t.length=n,t.pos=s,t.finished=i,t.destroyed=o,n%e&&t.buffer.set(r),t}};const g=(t,e,r)=>t&e^t&r^e&r,w=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),y=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),p=new Uint32Array(64);let b=class extends l{constructor(){super(64,32,8,!1),this.A=0|y[0],this.B=0|y[1],this.C=0|y[2],this.D=0|y[3],this.E=0|y[4],this.F=0|y[5],this.G=0|y[6],this.H=0|y[7]}get(){const{A:t,B:e,C:r,D:n,E:i,F:o,G:s,H:f}=this;return[t,e,r,n,i,o,s,f]}set(t,e,r,n,i,o,s,f){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|f}process(t,e){for(let r=0;r<16;r++,e+=4)p[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=p[t-15],r=p[t-2],n=a(e,7)^a(e,18)^e>>>3,i=a(r,17)^a(r,19)^r>>>10;p[t]=i+p[t-7]+n+p[t-16]|0}let{A:r,B:n,C:i,D:o,E:s,F:f,G:c,H:h}=this;for(let t=0;t<64;t++){const e=h+(a(s,6)^a(s,11)^a(s,25))+((u=s)&f^~u&c)+w[t]+p[t]|0,d=(a(r,2)^a(r,13)^a(r,22))+g(r,n,i)|0;h=c,c=f,f=s,s=o+e|0,o=i,i=n,n=r,r=e+d|0}var u;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,o=o+this.D|0,s=s+this.E|0,f=f+this.F|0,c=c+this.G|0,h=h+this.H|0,this.set(r,n,i,o,s,f,c,h)}roundClean(){p.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}},m=class extends b{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}};const x=u((()=>new b));u((()=>new m));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const E=BigInt(0),B=BigInt(1),v=BigInt(2),A=t=>t instanceof Uint8Array,I=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function S(t){if(!A(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=I[t[r]];return e}function U(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function _(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}function L(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(e/2);for(let e=0;e<r.length;e++){const n=2*e,i=t.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[e]=o}return r}function H(t){return _(S(t))}function $(t){if(!A(t))throw new Error("Uint8Array expected");return _(S(Uint8Array.from(t).reverse()))}function N(t,e){return L(t.toString(16).padStart(2*e,"0"))}function T(t,e){return N(t,e).reverse()}function O(t,e,r){let n;if("string"==typeof e)try{n=L(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!A(e))throw new Error(`${t} must be hex string or Uint8Array`);n=Uint8Array.from(e)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(`${t} expected ${r} bytes, got ${i}`);return n}function R(...t){const e=new Uint8Array(t.reduce(((t,e)=>t+e.length),0));let r=0;return t.forEach((t=>{if(!A(t))throw new Error("Uint8Array expected");e.set(t,r),r+=t.length})),e}const C=t=>(v<<BigInt(t-1))-B,k=t=>new Uint8Array(t),P=t=>Uint8Array.from(t);function z(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=k(t),i=k(t),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},f=(...t)=>r(i,n,...t),a=(t=k())=>{i=f(P([0]),t),n=f(),0!==t.length&&(i=f(P([1]),t),n=f())},c=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=f();const e=n.slice();r.push(e),t+=n.length}return R(...r)};return(t,e)=>{let r;for(s(),a(t);!(r=e(c()));)a();return s(),r}}const F={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function q(t,e,r={}){const n=(e,r,n)=>{const i=F[r];if("function"!=typeof i)throw new Error(`Invalid validator "${r}", expected function`);const o=t[e];if(!(n&&void 0===o||i(o,t)))throw new Error(`Invalid param ${String(e)}=${o} (${typeof o}), expected ${r}`)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}var D=Object.freeze({__proto__:null,bitGet:function(t,e){return t>>BigInt(e)&B},bitLen:function(t){let e;for(e=0;t>E;t>>=B,e+=1);return e},bitMask:C,bitSet:(t,e,r)=>t|(r?B:E)<<BigInt(e),bytesToHex:S,bytesToNumberBE:H,bytesToNumberLE:$,concatBytes:R,createHmacDrbg:z,ensureBytes:O,equalBytes:function(t,e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0},hexToBytes:L,hexToNumber:_,numberToBytesBE:N,numberToBytesLE:T,numberToHexUnpadded:U,numberToVarBytesBE:function(t){return L(U(t))},utf8ToBytes:function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))},validateObject:q});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const j=BigInt(0),V=BigInt(1),G=BigInt(2),W=BigInt(3),Y=BigInt(4),Z=BigInt(5),K=BigInt(8);function M(t,e){const r=t%e;return r>=j?r:e+r}function J(t,e,r){if(r<=j||e<j)throw new Error("Expected power/modulo > 0");if(r===V)return j;let n=V;for(;e>j;)e&V&&(n=n*t%r),t=t*t%r,e>>=V;return n}function Q(t,e,r){let n=t;for(;e-- >j;)n*=n,n%=r;return n}function X(t,e){if(t===j||e<=j)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=M(t,e),n=e,i=j,o=V;for(;r!==j;){const t=n%r,e=i-o*(n/r);n=r,r=t,i=o,o=e}if(n!==V)throw new Error("invert: does not exist");return M(i,e)}function tt(t){if(t%Y===W){const e=(t+V)/Y;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}if(t%K===Z){const e=(t-Z)/K;return function(t,r){const n=t.mul(r,G),i=t.pow(n,e),o=t.mul(r,i),s=t.mul(t.mul(o,G),i),f=t.mul(o,t.sub(s,t.ONE));if(!t.eql(t.sqr(f),r))throw new Error("Cannot find square root");return f}}return function(t){const e=(t-V)/G;let r,n,i;for(r=t-V,n=0;r%G===j;r/=G,n++);for(i=G;i<t&&J(i,e,t)!==t-V;i++);if(1===n){const e=(t+V)/Y;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}const o=(r+V)/G;return function(t,s){if(t.pow(s,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let f=n,a=t.pow(t.mul(t.ONE,i),r),c=t.pow(s,o),h=t.pow(s,r);for(;!t.eql(h,t.ONE);){if(t.eql(h,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(h);e<f&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(a,V<<BigInt(f-e-1));a=t.sqr(r),c=t.mul(c,r),h=t.mul(h,a),f=e}return c}}(t)}BigInt(9),BigInt(16);const et=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function rt(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function nt(t,e,r=!1,n={}){if(t<=j)throw new Error(`Expected Fp ORDER > 0, got ${t}`);const{nBitLength:i,nByteLength:o}=rt(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=tt(t),f=Object.freeze({ORDER:t,BITS:i,BYTES:o,MASK:C(i),ZERO:j,ONE:V,create:e=>M(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return j<=e&&e<t},is0:t=>t===j,isOdd:t=>(t&V)===V,neg:e=>M(-e,t),eql:(t,e)=>t===e,sqr:e=>M(e*e,t),add:(e,r)=>M(e+r,t),sub:(e,r)=>M(e-r,t),mul:(e,r)=>M(e*r,t),pow:(t,e)=>function(t,e,r){if(r<j)throw new Error("Expected power > 0");if(r===j)return t.ONE;if(r===V)return e;let n=t.ONE,i=e;for(;r>j;)r&V&&(n=t.mul(n,i)),i=t.sqr(i),r>>=V;return n}(f,t,e),div:(e,r)=>M(e*X(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>X(e,t),sqrt:n.sqrt||(t=>s(f,t)),invertBatch:t=>function(t,e){const r=new Array(e.length),n=e.reduce(((e,n,i)=>t.is0(n)?e:(r[i]=e,t.mul(e,n))),t.ONE),i=t.inv(n);return e.reduceRight(((e,n,i)=>t.is0(n)?e:(r[i]=t.mul(e,r[i]),t.mul(e,n))),i),r}(f,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?T(t,o):N(t,o),fromBytes:t=>{if(t.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${t.length}`);return r?$(t):H(t)}});return Object.freeze(f)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const it=BigInt(0),ot=BigInt(1);function st(t){return q(t.Fp,et.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),q(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...rt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const{bytesToNumberBE:ft,hexToBytes:at}=D,ct={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=ct;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],n=t.subarray(2,r+2);if(!r||n.length!==r)throw new e("Invalid signature integer: wrong length");if(128&n[0])throw new e("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:ft(n),l:t.subarray(r+2)}},toSig(t){const{Err:e}=ct,r="string"==typeof t?at(t):t;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:i,l:o}=ct._parseInt(r.subarray(2)),{d:s,l:f}=ct._parseInt(o);if(f.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s:s}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},n=e(r(t.s)),i=e(r(t.r)),o=n.length/2,s=i.length/2,f=r(o),a=r(s);return`30${r(s+o+4)}02${a}${i}02${f}${n}`}},ht=BigInt(0),ut=BigInt(1);BigInt(2);const dt=BigInt(3);function lt(t){const e=function(t){const e=st(t);q(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=e;if(r){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=e.toBytes||((t,e,n)=>{const i=e.toAffine();return R(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),i=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function o(t){const{a:n,b:i}=e,o=r.sqr(t),s=r.mul(o,t);return r.add(r.add(s,r.mul(t,n)),i)}if(!r.eql(r.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function s(t){return"bigint"==typeof t&&ht<t&&t<e.n}function f(t){if(!s(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=e;if(r&&"bigint"!=typeof t){if(t instanceof Uint8Array&&(t=S(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:H(O("private key",t,n))}catch(e){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)}return i&&(s=M(s,o)),f(s),s}const c=new Map;function h(t){if(!(t instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof u)throw new Error("projective point not allowed");const i=t=>r.eql(t,r.ZERO);return i(e)&&i(n)?u.ZERO:new u(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(u.fromAffine)}static fromHex(t){const e=u.fromAffine(i(O("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return u.BASE.multiply(a(t))}_setWindowSize(t){this._WINDOW_SIZE=t,c.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw new Error("bad point: x or y not FE");const i=r.sqr(n),s=o(t);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){h(t);const{px:e,py:n,pz:i}=this,{px:o,py:s,pz:f}=t,a=r.eql(r.mul(e,f),r.mul(o,i)),c=r.eql(r.mul(n,f),r.mul(s,i));return a&&c}negate(){return new u(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,i=r.mul(n,dt),{px:o,py:s,pz:f}=this;let a=r.ZERO,c=r.ZERO,h=r.ZERO,d=r.mul(o,o),l=r.mul(s,s),g=r.mul(f,f),w=r.mul(o,s);return w=r.add(w,w),h=r.mul(o,f),h=r.add(h,h),a=r.mul(t,h),c=r.mul(i,g),c=r.add(a,c),a=r.sub(l,c),c=r.add(l,c),c=r.mul(a,c),a=r.mul(w,a),h=r.mul(i,h),g=r.mul(t,g),w=r.sub(d,g),w=r.mul(t,w),w=r.add(w,h),h=r.add(d,d),d=r.add(h,d),d=r.add(d,g),d=r.mul(d,w),c=r.add(c,d),g=r.mul(s,f),g=r.add(g,g),d=r.mul(g,w),a=r.sub(a,d),h=r.mul(g,l),h=r.add(h,h),h=r.add(h,h),new u(a,c,h)}add(t){h(t);const{px:n,py:i,pz:o}=this,{px:s,py:f,pz:a}=t;let c=r.ZERO,d=r.ZERO,l=r.ZERO;const g=e.a,w=r.mul(e.b,dt);let y=r.mul(n,s),p=r.mul(i,f),b=r.mul(o,a),m=r.add(n,i),x=r.add(s,f);m=r.mul(m,x),x=r.add(y,p),m=r.sub(m,x),x=r.add(n,o);let E=r.add(s,a);return x=r.mul(x,E),E=r.add(y,b),x=r.sub(x,E),E=r.add(i,o),c=r.add(f,a),E=r.mul(E,c),c=r.add(p,b),E=r.sub(E,c),l=r.mul(g,x),c=r.mul(w,b),l=r.add(c,l),c=r.sub(p,l),l=r.add(p,l),d=r.mul(c,l),p=r.add(y,y),p=r.add(p,y),b=r.mul(g,b),x=r.mul(w,x),p=r.add(p,b),b=r.sub(y,b),b=r.mul(g,b),x=r.add(x,b),y=r.mul(p,x),d=r.add(d,y),y=r.mul(E,x),c=r.mul(m,c),c=r.sub(c,y),y=r.mul(m,p),l=r.mul(E,l),l=r.add(l,y),new u(c,d,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(u.ZERO)}wNAF(t){return l.wNAFCached(this,c,t,(t=>{const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(u.fromAffine)}))}multiplyUnsafe(t){const n=u.ZERO;if(t===ht)return n;if(f(t),t===ut)return this;const{endo:i}=e;if(!i)return l.unsafeLadder(this,t);let{k1neg:o,k1:s,k2neg:a,k2:c}=i.splitScalar(t),h=n,d=n,g=this;for(;s>ht||c>ht;)s&ut&&(h=h.add(g)),c&ut&&(d=d.add(g)),g=g.double(),s>>=ut,c>>=ut;return o&&(h=h.negate()),a&&(d=d.negate()),d=new u(r.mul(d.px,i.beta),d.py,d.pz),h.add(d)}multiply(t){f(t);let n,i,o=t;const{endo:s}=e;if(s){const{k1neg:t,k1:e,k2neg:f,k2:a}=s.splitScalar(o);let{p:c,f:h}=this.wNAF(e),{p:d,f:g}=this.wNAF(a);c=l.constTimeNegate(t,c),d=l.constTimeNegate(f,d),d=new u(r.mul(d.px,s.beta),d.py,d.pz),n=c.add(d),i=h.add(g)}else{const{p:t,f:e}=this.wNAF(o);n=t,i=e}return u.normalizeZ([n,i])[0]}multiplyAndAddUnsafe(t,e,r){const n=u.BASE,i=(t,e)=>e!==ht&&e!==ut&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),o=i(this,e).add(i(t,r));return o.is0()?void 0:o}toAffine(t){const{px:e,py:n,pz:i}=this,o=this.is0();null==t&&(t=o?r.ONE:r.inv(i));const s=r.mul(e,t),f=r.mul(n,t),a=r.mul(i,t);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(a,r.ONE))throw new Error("invZ was invalid");return{x:s,y:f}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===ut)return!0;if(r)return r(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===ut?this:r?r(u,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),n(u,this,t)}toHex(t=!0){return S(this.toRawBytes(t))}}u.BASE=new u(e.Gx,e.Gy,r.ONE),u.ZERO=new u(r.ZERO,r.ONE,r.ZERO);const d=e.nBitLength,l=function(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},n=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let n=t.ZERO,i=e;for(;r>it;)r&ot&&(n=n.add(i)),i=i.double(),r>>=ot;return n},precomputeWindow(t,e){const{windows:r,windowSize:i}=n(e),o=[];let s=t,f=s;for(let t=0;t<r;t++){f=s,o.push(f);for(let t=1;t<i;t++)f=f.add(s),o.push(f);s=f.double()}return o},wNAF(e,i,o){const{windows:s,windowSize:f}=n(e);let a=t.ZERO,c=t.BASE;const h=BigInt(2**e-1),u=2**e,d=BigInt(e);for(let t=0;t<s;t++){const e=t*f;let n=Number(o&h);o>>=d,n>f&&(n-=u,o+=ot);const s=e,l=e+Math.abs(n)-1,g=t%2!=0,w=n<0;0===n?c=c.add(r(g,i[s])):a=a.add(r(w,i[l]))}return{p:a,f:c}},wNAFCached(t,e,r,n){const i=t._WINDOW_SIZE||1;let o=e.get(t);return o||(o=this.precomputeWindow(t,i),1!==i&&e.set(t,n(o))),this.wNAF(i,o,r)}}}(u,e.endo?Math.ceil(d/2):d);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:s}}function gt(t){const e=function(t){const e=st(t);return q(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n:n}=e,i=r.BYTES+1,o=2*r.BYTES+1;function s(t){return M(t,n)}function f(t){return X(t,n)}const{ProjectivePoint:a,normPrivateKeyToScalar:c,weierstrassEquation:h,isWithinCurveOrder:u}=lt({...e,toBytes(t,e,n){const i=e.toAffine(),o=r.toBytes(i.x),s=R;return n?s(Uint8Array.from([e.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(t){const e=t.length,n=t[0],s=t.subarray(1);if(e!==i||2!==n&&3!==n){if(e===o&&4===n){return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${e} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}{const t=H(s);if(!(ht<(f=t)&&f<r.ORDER))throw new Error("Point is not on curve");const e=h(t);let i=r.sqrt(e);return 1==(1&n)!==((i&ut)===ut)&&(i=r.neg(i)),{x:t,y:i}}var f}}),d=t=>S(N(t,e.nByteLength));function l(t){return t>n>>ut}const g=(t,e,r)=>H(t.slice(e,r));class w{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=O("compactSignature",t,2*r),new w(g(t,0,r),g(t,r,2*r))}static fromDER(t){const{r:e,s:r}=ct.toSig(O("DER",t));return new w(e,r)}assertValidity(){if(!u(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!u(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new w(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:i,recovery:o}=this,c=m(O("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const h=2===o||3===o?n+e.n:n;if(h>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const u=0==(1&o)?"02":"03",l=a.fromHex(u+d(h)),g=f(h),w=s(-c*g),y=s(i*g),p=a.BASE.multiplyAndAddUnsafe(l,w,y);if(!p)throw new Error("point at infinify");return p.assertValidity(),p}hasHighS(){return l(this.s)}normalizeS(){return this.hasHighS()?new w(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return L(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return L(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const y={isValidPrivateKey(t){try{return c(t),!0}catch(t){return!1}},normPrivateKeyToScalar:c,randomPrivateKey:()=>{const t=function(t,e,r=!1){const n=(t=O("privateHash",t)).length,i=rt(e).nByteLength+8;if(i<24||n<i||n>1024)throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);return M(r?$(t):H(t),e-V)+V}(e.randomBytes(r.BYTES+8),n);return N(t,e.nByteLength)},precompute:(t=8,e=a.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function p(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?n===i||n===o:r?n===2*i||n===2*o:t instanceof a}const b=e.bits2int||function(t){const r=H(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r},m=e.bits2int_modN||function(t){return s(b(t))},x=C(e.nBitLength);function E(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(ht<=t&&t<x))throw new Error(`bigint expected < 2^${e.nBitLength}`);return N(t,e.nByteLength)}function B(t,n,i=v){if(["recovered","canonical"].some((t=>t in i)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:h}=e;let{lowS:d,prehash:g,extraEntropy:y}=i;null==d&&(d=!0),t=O("msgHash",t),g&&(t=O("prehashed msgHash",o(t)));const p=m(t),x=c(n),B=[E(x),E(p)];if(null!=y){const t=!0===y?h(r.BYTES):y;B.push(O("extraEntropy",t,r.BYTES))}const A=R(...B),I=p;return{seed:A,k2sig:function(t){const e=b(t);if(!u(e))return;const r=f(e),n=a.BASE.multiply(e).toAffine(),i=s(n.x);if(i===ht)return;const o=s(r*s(I+i*x));if(o===ht)return;let c=(n.x===i?0:2)|Number(n.y&ut),h=o;return d&&l(o)&&(h=function(t){return l(t)?s(-t):t}(o),c^=1),new w(i,h,c)}}}const v={lowS:e.lowS,prehash:!1},A={lowS:e.lowS,prehash:!1};return a.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return a.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(p(t))throw new Error("first arg must be private key");if(!p(e))throw new Error("second arg must be public key");return a.fromHex(e).multiply(c(t)).toRawBytes(r)},sign:function(t,r,n=v){const{seed:i,k2sig:o}=B(t,r,n),s=e;return z(s.hash.outputLen,s.nByteLength,s.hmac)(i,o)},verify:function(t,r,n,i=A){const o=t;if(r=O("msgHash",r),n=O("publicKey",n),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:c,prehash:h}=i;let u,d;try{if("string"==typeof o||o instanceof Uint8Array)try{u=w.fromDER(o)}catch(t){if(!(t instanceof ct.Err))throw t;u=w.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:t,s:e}=o;u=new w(t,e)}}d=a.fromHex(n)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(c&&u.hasHighS())return!1;h&&(r=e.hash(r));const{r:l,s:g}=u,y=m(r),p=f(g),b=s(y*p),x=s(l*p),E=a.BASE.multiplyAndAddUnsafe(d,b,x)?.toAffine();return!!E&&s(E.x)===l},ProjectivePoint:a,Signature:w,utils:y}}BigInt(4);class wt extends h{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,i.hash(t);const r=c(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,o=new Uint8Array(n);o.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<o.length;t++)o[t]^=54;this.iHash.update(o),this.oHash=t.create();for(let t=0;t<o.length;t++)o[t]^=106;this.oHash.update(o),o.fill(0)}update(t){return i.exists(this),this.iHash.update(t),this}digestInto(t){i.exists(this),i.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:i,blockLen:o,outputLen:s}=this;return t.finished=n,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const yt=(t,e,r)=>new wt(t,e).update(r).digest();
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function pt(t){return{hash:t,hmac:(e,...r)=>yt(t,e,function(...t){const e=new Uint8Array(t.reduce(((t,e)=>t+e.length),0));let r=0;return t.forEach((t=>{if(!s(t))throw new Error("Uint8Array expected");e.set(t,r),r+=t.length})),e}(...r)),randomBytes:d}}yt.create=(t,e)=>new wt(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const bt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),mt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),xt=BigInt(1),Et=BigInt(2),Bt=(t,e)=>(t+e/Et)/e;function vt(t){const e=bt,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),f=BigInt(44),a=BigInt(88),c=t*t*t%e,h=c*c*t%e,u=Q(h,r,e)*h%e,d=Q(u,r,e)*h%e,l=Q(d,Et,e)*c%e,g=Q(l,i,e)*l%e,w=Q(g,o,e)*g%e,y=Q(w,f,e)*w%e,p=Q(y,a,e)*y%e,b=Q(p,f,e)*w%e,m=Q(b,r,e)*h%e,x=Q(m,s,e)*g%e,E=Q(x,n,e)*c%e,B=Q(E,Et,e);if(!At.eql(At.sqr(B),t))throw new Error("Cannot find square root");return B}const At=nt(bt,void 0,void 0,{sqrt:vt}),It=function(t,e){const r=e=>gt({...t,...pt(e)});return Object.freeze({...r(e),create:r})}({a:BigInt(0),b:BigInt(7),Fp:At,n:mt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=mt,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-xt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),f=Bt(o*t,e),a=Bt(-n*t,e);let c=M(t-f*r-a*i,e),h=M(-f*n-a*o,e);const u=c>s,d=h>s;if(u&&(c=e-c),d&&(h=e-h),c>s||h>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:c,k2neg:d,k2:h}}}},x),St=BigInt(0),Ut=t=>"bigint"==typeof t&&St<t&&t<bt,_t=t=>"bigint"==typeof t&&St<t&&t<mt,Lt={};function Ht(t,...e){let r=Lt[t];if(void 0===r){const e=x(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=R(e,e),Lt[t]=r}return x(R(r,...e))}const $t=t=>t.toRawBytes(!0).slice(1),Nt=t=>N(t,32),Tt=t=>M(t,bt),Ot=t=>M(t,mt),Rt=It.ProjectivePoint,Ct=(t,e,r)=>Rt.BASE.multiplyAndAddUnsafe(t,e,r);function kt(t){let e=It.utils.normPrivateKeyToScalar(t),r=Rt.fromPrivateKey(e);return{scalar:r.hasEvenY()?e:Ot(-e),bytes:$t(r)}}function Pt(t){if(!Ut(t))throw new Error("bad x: need 0 < x < p");const e=Tt(t*t);let r=vt(Tt(e*t+BigInt(7)));r%Et!==St&&(r=Tt(-r));const n=new Rt(t,r,xt);return n.assertValidity(),n}function zt(...t){return Ot(H(Ht("BIP0340/challenge",...t)))}function Ft(t){return kt(t).bytes}function qt(t,e,r=d(32)){const n=O("message",t),{bytes:i,scalar:o}=kt(e),s=O("auxRand",r,32),f=Nt(o^H(Ht("BIP0340/aux",s))),a=Ht("BIP0340/nonce",f,i,n),c=Ot(H(a));if(c===St)throw new Error("sign failed: k is zero");const{bytes:h,scalar:u}=kt(c),l=zt(h,i,n),g=new Uint8Array(64);if(g.set(h,0),g.set(Nt(Ot(u+l*o)),32),!Dt(g,n,i))throw new Error("sign: Invalid signature produced");return g}function Dt(t,e,r){const n=O("signature",t,64),i=O("message",e),o=O("publicKey",r,32);try{const t=Pt(H(o)),e=H(n.subarray(0,32));if(!Ut(e))return!1;const r=H(n.subarray(32,64));if(!_t(r))return!1;const s=zt(Nt(e),$t(t),i),f=Ct(t,r,Ot(-s));return!(!f||!f.hasEvenY()||f.toAffine().x!==e)}catch(t){return!1}}const jt=(()=>({getPublicKey:Ft,sign:qt,verify:Dt,utils:{randomPrivateKey:It.utils.randomPrivateKey,lift_x:Pt,pointToBytes:$t,numberToBytesBE:N,bytesToNumberBE:H,taggedHash:Ht,mod:M}}))();function Vt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function Gt(t,...e){if(!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}const Wt={number:Vt,bool:function(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)},bytes:Gt,hash:function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");Vt(t.outputLen),Vt(t.blockLen)},exists:function(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")},output:function(t,e){Gt(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}};var Yt=Wt;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Kt=(t,e)=>t<<32-e|t>>>e;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function Mt(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new TypeError("utf8ToBytes expected string, got "+typeof t);return(new TextEncoder).encode(t)}(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));class Jt{clone(){return this._cloneInto()}}function Qt(t){const e=e=>t().update(Mt(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}class Xt extends Jt{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Zt(this.buffer)}update(t){Yt.exists(this);const{view:e,buffer:r,blockLen:n}=this,i=(t=Mt(t)).length;for(let o=0;o<i;){const s=Math.min(n-this.pos,i-o);if(s!==n)r.set(t.subarray(o,o+s),this.pos),this.pos+=s,o+=s,this.pos===n&&(this.process(e,0),this.pos=0);else{const e=Zt(t);for(;n<=i-o;o+=n)this.process(e,o)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){Yt.exists(this),Yt.output(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:i}=this;let{pos:o}=this;e[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>n-o&&(this.process(r,0),o=0);for(let t=o;t<n;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),f=Number(r&o),a=n?4:0,c=n?0:4;t.setUint32(e+a,s,n),t.setUint32(e+c,f,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const s=Zt(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,c=this.get();if(a>c.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<a;t++)s.setUint32(4*t,c[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return t.length=n,t.pos=s,t.finished=i,t.destroyed=o,n%e&&t.buffer.set(r),t}}const te=(t,e,r)=>t&e^t&r^e&r,ee=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),re=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ne=new Uint32Array(64);class ie extends Xt{constructor(){super(64,32,8,!1),this.A=0|re[0],this.B=0|re[1],this.C=0|re[2],this.D=0|re[3],this.E=0|re[4],this.F=0|re[5],this.G=0|re[6],this.H=0|re[7]}get(){const{A:t,B:e,C:r,D:n,E:i,F:o,G:s,H:f}=this;return[t,e,r,n,i,o,s,f]}set(t,e,r,n,i,o,s,f){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|f}process(t,e){for(let r=0;r<16;r++,e+=4)ne[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=ne[t-15],r=ne[t-2],n=Kt(e,7)^Kt(e,18)^e>>>3,i=Kt(r,17)^Kt(r,19)^r>>>10;ne[t]=i+ne[t-7]+n+ne[t-16]|0}let{A:r,B:n,C:i,D:o,E:s,F:f,G:a,H:c}=this;for(let t=0;t<64;t++){const e=c+(Kt(s,6)^Kt(s,11)^Kt(s,25))+((h=s)&f^~h&a)+ee[t]+ne[t]|0,u=(Kt(r,2)^Kt(r,13)^Kt(r,22))+te(r,n,i)|0;c=a,a=f,f=s,s=o+e|0,o=i,i=n,n=r,r=e+u|0}var h;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,o=o+this.D|0,s=s+this.E|0,f=f+this.F|0,a=a+this.G|0,c=c+this.H|0,this.set(r,n,i,o,s,f,a,c)}roundClean(){ne.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class oe extends ie{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const se=Qt((()=>new ie));
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function fe(t){if(!Number.isSafeInteger(t))throw new Error(`Wrong integer: ${t}`)}function ae(...t){const e=(t,e)=>r=>t(e(r));return{encode:Array.from(t).reverse().reduce(((t,r)=>t?e(t,r.encode):r.encode),void 0),decode:t.reduce(((t,r)=>t?e(t,r.decode):r.decode),void 0)}}function ce(t){return{encode:e=>{if(!Array.isArray(e)||e.length&&"number"!=typeof e[0])throw new Error("alphabet.encode input should be an array of numbers");return e.map((e=>{if(fe(e),e<0||e>=t.length)throw new Error(`Digit index outside alphabet: ${e} (alphabet: ${t.length})`);return t[e]}))},decode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("alphabet.decode input should be array of strings");return e.map((e=>{if("string"!=typeof e)throw new Error(`alphabet.decode: not string element=${e}`);const r=t.indexOf(e);if(-1===r)throw new Error(`Unknown letter: "${e}". Allowed: ${t}`);return r}))}}}function he(t=""){if("string"!=typeof t)throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("join.encode input should be array of strings");for(let t of e)if("string"!=typeof t)throw new Error(`join.encode: non-string input=${t}`);return e.join(t)},decode:e=>{if("string"!=typeof e)throw new Error("join.decode input should be string");return e.split(t)}}}function ue(t,e="="){if(fe(t),"string"!=typeof e)throw new Error("padding chr should be string");return{encode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let t of r)if("string"!=typeof t)throw new Error(`padding.encode: non-string input=${t}`);for(;r.length*t%8;)r.push(e);return r},decode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let t of r)if("string"!=typeof t)throw new Error(`padding.decode: non-string input=${t}`);let n=r.length;if(n*t%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;n>0&&r[n-1]===e;n--)if(!((n-1)*t%8))throw new Error("Invalid padding: string has too much padding");return r.slice(0,n)}}}function de(t){if("function"!=typeof t)throw new Error("normalize fn should be function");return{encode:t=>t,decode:e=>t(e)}}function le(t,e,r){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);if(!Array.isArray(t))throw new Error("convertRadix: data should be array");if(!t.length)return[];let n=0;const i=[],o=Array.from(t);for(o.forEach((t=>{if(fe(t),t<0||t>=e)throw new Error(`Wrong integer: ${t}`)}));;){let t=0,s=!0;for(let i=n;i<o.length;i++){const f=o[i],a=e*t+f;if(!Number.isSafeInteger(a)||e*t/e!==t||a-f!=e*t)throw new Error("convertRadix: carry overflow");if(t=a%r,o[i]=Math.floor(a/r),!Number.isSafeInteger(o[i])||o[i]*r+t!==a)throw new Error("convertRadix: carry overflow");s&&(o[i]?s=!1:n=i)}if(i.push(t),s)break}for(let e=0;e<t.length-1&&0===t[e];e++)i.push(0);return i.reverse()}Qt((()=>new oe));const ge=(t,e)=>e?ge(e,t%e):t,we=(t,e)=>t+(e-ge(t,e));function ye(t,e,r,n){if(!Array.isArray(t))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(we(e,r)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${we(e,r)}`);let i=0,o=0;const s=2**r-1,f=[];for(const n of t){if(fe(n),n>=2**e)throw new Error(`convertRadix2: invalid data word=${n} from=${e}`);if(i=i<<e|n,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=r;o-=r)f.push((i>>o-r&s)>>>0);i&=2**o-1}if(i=i<<r-o&s,!n&&o>=e)throw new Error("Excess padding");if(!n&&i)throw new Error(`Non-zero padding: ${i}`);return n&&o>0&&f.push(i>>>0),f}function pe(t,e=!1){if(fe(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(we(8,t)>32||we(t,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!(r instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return ye(Array.from(r),8,t,!e)},decode:r=>{if(!Array.isArray(r)||r.length&&"number"!=typeof r[0])throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(ye(r,t,8,e))}}}function be(t){if("function"!=typeof t)throw new Error("unsafeWrapper fn should be function");return function(...e){try{return t.apply(null,e)}catch(t){}}}const me=ae(pe(4),ce("0123456789ABCDEF"),he("")),xe=ae(pe(5),ce("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),ue(5),he(""));ae(pe(5),ce("0123456789ABCDEFGHIJKLMNOPQRSTUV"),ue(5),he("")),ae(pe(5),ce("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),he(""),de((t=>t.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))));const Ee=ae(pe(6),ce("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),ue(6),he("")),Be=ae(pe(6),ce("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),ue(6),he("")),ve=t=>{return ae((fe(e=58),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return le(Array.from(t),256,e)},decode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("radix.decode input should be array of strings");return Uint8Array.from(le(t,e,256))}}),ce(t),he(""));var e},Ae=ve("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");ve("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),ve("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const Ie=[0,2,3,5,6,7,9,10,11],Se={encode(t){let e="";for(let r=0;r<t.length;r+=8){const n=t.subarray(r,r+8);e+=Ae.encode(n).padStart(Ie[n.length],"1")}return e},decode(t){let e=[];for(let r=0;r<t.length;r+=11){const n=t.slice(r,r+11),i=Ie.indexOf(n.length),o=Ae.decode(n);for(let t=0;t<o.length-i;t++)if(0!==o[t])throw new Error("base58xmr: wrong padding");e=e.concat(Array.from(o.slice(o.length-i)))}return Uint8Array.from(e)}},Ue=t=>ae(function(t,e){if(fe(t),"function"!=typeof e)throw new Error("checksum fn should be function");return{encode(r){if(!(r instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const n=e(r).slice(0,t),i=new Uint8Array(r.length+t);return i.set(r),i.set(n,r.length),i},decode(r){if(!(r instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-t),i=e(n).slice(0,t),o=r.slice(-t);for(let e=0;e<t;e++)if(i[e]!==o[e])throw new Error("Invalid checksum");return n}}}(4,(e=>t(t(e)))),Ae),_e=ae(ce("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),he("")),Le=[996825010,642813549,513874426,1027748829,705979059];function He(t){const e=t>>25;let r=(33554431&t)<<5;for(let t=0;t<Le.length;t++)1==(e>>t&1)&&(r^=Le[t]);return r}function $e(t,e,r=1){const n=t.length;let i=1;for(let e=0;e<n;e++){const r=t.charCodeAt(e);if(r<33||r>126)throw new Error(`Invalid prefix (${t})`);i=He(i)^r>>5}i=He(i);for(let e=0;e<n;e++)i=He(i)^31&t.charCodeAt(e);for(let t of e)i=He(i)^t;for(let t=0;t<6;t++)i=He(i);return i^=r,_e.encode(ye([i%2**30],30,5,!1))}function Ne(t){const e="bech32"===t?1:734539939,r=pe(5),n=r.decode,i=r.encode,o=be(n);function s(t,r=90){if("string"!=typeof t)throw new Error("bech32.decode input should be string, not "+typeof t);if(t.length<8||!1!==r&&t.length>r)throw new TypeError(`Wrong string length: ${t.length} (${t}). Expected (8..${r})`);const n=t.toLowerCase();if(t!==n&&t!==t.toUpperCase())throw new Error("String must be lowercase or uppercase");const i=(t=n).lastIndexOf("1");if(0===i||-1===i)throw new Error('Letter "1" must be present between prefix and data only');const o=t.slice(0,i),s=t.slice(i+1);if(s.length<6)throw new Error("Data must be at least 6 characters long");const f=_e.decode(s).slice(0,-6),a=$e(o,f,e);if(!s.endsWith(a))throw new Error(`Invalid checksum in ${t}: expected "${a}"`);return{prefix:o,words:f}}return{encode:function(t,r,n=90){if("string"!=typeof t)throw new Error("bech32.encode prefix should be string, not "+typeof t);if(!Array.isArray(r)||r.length&&"number"!=typeof r[0])throw new Error("bech32.encode words should be array of numbers, not "+typeof r);const i=t.length+7+r.length;if(!1!==n&&i>n)throw new TypeError(`Length ${i} exceeds limit ${n}`);return`${t=t.toLowerCase()}1${_e.encode(r)}${$e(t,r,e)}`},decode:s,decodeToBytes:function(t){const{prefix:e,words:r}=s(t,!1);return{prefix:e,words:r,bytes:n(r)}},decodeUnsafe:be(s),fromWords:n,fromWordsUnsafe:o,toWords:i}}const Te=Ne("bech32"),Oe=Ne("bech32m"),Re={utf8:{encode:t=>(new TextDecoder).decode(t),decode:t=>(new TextEncoder).encode(t)},hex:ae(pe(4),ce("0123456789abcdef"),he(""),de((t=>{if("string"!=typeof t||t.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);return t.toLowerCase()}))),base16:me,base32:xe,base64:Ee,base64url:Be,base58:Ae,base58xmr:Se};Object.keys(Re).join(", ");const Ce={encode:t=>Ue(se).encode(t),decode:t=>Ue(se).decode(t)},ke={encode:t=>Ee.encode(t),decode:t=>Ee.decode(t)},Pe={encode:t=>Be.encode(t),decode:t=>Be.decode(t)},ze={into_words:Te.toWords,from_words:Te.fromWords,encode:(t,e,r=!1)=>Te.encode(t,Te.toWords(e),r),decode:(t,e=!1)=>{const{prefix:r,words:n}=Te.decode(t,e);return{prefix:r,words:n,bytes:Te.fromWords(n)}}},Fe={into_words:Oe.toWords,from_words:Oe.fromWords,encode:(t,e,r=!1)=>Oe.encode(t,Oe.toWords(e),r),decode:(t,e=!1)=>{const{prefix:r,words:n}=Oe.decode(t,e);return{prefix:r,words:n,bytes:Oe.fromWords(n)}}};function qe(t){if(t>Number.MAX_SAFE_INTEGER)throw new TypeError("Number exceeds safe bounds!")}function De(t,e){if(t!==e)throw new TypeError(`Bech32 prefix does not match: ${t} !== ${e}`)}const je=BigInt(0),Ve=BigInt(255),Ge=BigInt(256);function We(t,e,r="be"){void 0===e&&(e=function(t){if(t<=0xffn)return 1;if(t<=0xffffn)return 2;if(t<=0xffffffffn)return 4;if(t<=0xffffffffffffffffn)return 8;if(t<=0xffffffffffffffffffffffffffffffffn)return 16;if(t<=0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)return 32;throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.")}(t));const n="le"===r,i=new ArrayBuffer(e),o=new DataView(i);let s=n?0:e-1;for(;t>je;){const e=t&Ve,r=Number(e);n?o.setUint8(s++,r):o.setUint8(s--,r),t=(t-e)/Ge}return new Uint8Array(i)}function Ye(t,e,r="be"){void 0===e&&(e=function(t){if(t<=255)return 1;if(t<=65535)return 2;if(t<=4294967295)return 4;throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!")}(t));const n="le"===r,i=new ArrayBuffer(e),o=new DataView(i);let s=n?0:e-1;for(;t>0;){const e=255&t;n?o.setUint8(s++,t):o.setUint8(s--,t),t=(t-e)/256}return new Uint8Array(i)}const Ze=new TextEncoder,Ke=new TextDecoder;function Me(t){return Ze.encode(t)}function Je(t){return Ke.decode(t)}function Qe(t,e){!function(t){if(null!==t.match(/[^a-fA-f0-9]/))throw new TypeError("Invalid characters in hex string: "+t);if(t.length%2!=0)throw new Error(`Length of hex string is invalid: ${t.length}`)}(t);const r=t.length/2;if(void 0===e&&(e=r),r>e)throw new TypeError(`Hex string is larger than array size: ${r} > ${e}`);return e}const{getRandomValues:Xe}=crypto??globalThis.crypto??window.crypto;function tr(t,e,r="be"){void 0===e&&(e=t.length),function(t,e){if(t.length>e)throw new TypeError(`Data is larger than array size: ${t.length} > ${e}`)}(t,e);const n=new Uint8Array(e).fill(0),i="be"===r?0:e-t.length;return n.set(t,i),n}function er(t){let e,r=0;const n=t.reduce(((t,e)=>t+e.length),0),i=new Uint8Array(n);for(e=0;e<t.length;e++){const n=t[e];i.set(n,r),r+=n.length}return i}function rr(t,e){return"bigint"==typeof e?`${e}n`:e}function nr(t,e){return"string"==typeof e&&/n$/.test(e)?BigInt(e.slice(0,-1)):e}function ir(t,e,r){if(t instanceof ArrayBuffer)return new Uint8Array(t);if(t instanceof Uint8Array)return tr(t,e,r);if(Array.isArray(t))try{return er(t.map((t=>ir(t,e,r))))}catch(t){const{message:e}=t;throw new TypeError("Invalid data caught in array."+e)}if("string"==typeof t)return function(t,e,r="le"){e=Qe(t,e);const n="le"===r,i=new ArrayBuffer(e),o=new DataView(i);let s=n?0:e-1;for(let e=0;e<t.length;e+=2){const r=t.substring(e,e+2),i=parseInt(r,16);n?o.setUint8(s++,i):o.setUint8(s--,i)}return new Uint8Array(i)}(t,e,r);if("bigint"==typeof t)return We(t,e,r);if("number"==typeof t)return Ye(t,e,r);if("boolean"==typeof t)return Uint8Array.of(t?1:0);throw new TypeError("Unsupported format:"+String(typeof t))}class or extends Uint8Array{static{this.num=sr}static{this.big=ar}static{this.bin=fr}static{this.raw=cr}static{this.str=hr}static{this.hex=ur}static{this.bytes=mr}static{this.json=dr}static{this.base64=lr}static{this.b64url=gr}static{this.bech32=wr}static{this.bech32m=yr}static{this.b58chk=pr}static{this.encode=Me}static{this.decode=Je}static random(t=32){const e=function(t=32){if("function"==typeof Xe)return crypto.getRandomValues(new Uint8Array(t));throw new Error("Crypto module missing getRandomValues!")}(t);return new or(e,t)}constructor(t,e,r){if(t instanceof or&&void 0===e)return t;super(ir(t,e,r))}get arr(){return[...this]}get num(){return this.toNum()}get big(){return this.toBig()}get str(){return this.toStr()}get hex(){return this.toHex()}get raw(){return new Uint8Array(this)}get bin(){return this.toBin()}get b58chk(){return this.tob58chk()}get base64(){return this.toBase64()}get b64url(){return this.toB64url()}get digest(){return this.toHash()}get id(){return this.toHash().hex}get stream(){return new br(this)}toNum(t="be"){return function(t){let e=0;for(let r=t.length-1;r>=0;r--)e=256*e+t[r],qe(e);return e}("be"===t?this.reverse():this)}toBig(t="be"){return function(t){let e=BigInt(0);for(let r=t.length-1;r>=0;r--)e=e*Ge+BigInt(t[r]);return BigInt(e)}("be"===t?this.reverse():this)}toBin(){return function(t){const e=new Array(8*t.length);let r=0;for(const n of t){if(n>255)throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);for(let t=7;t>=0;t--,r++)e[r]=n>>t&1}return e.join("")}(this)}toHash(){const t=se(this);return new or(t)}toJson(t){void 0===t&&(t=nr);const e=Je(this);return JSON.parse(e,t)}toBech32(t,e){return ze.encode(t,this,e)}toBech32m(t,e){return Fe.encode(t,this,e)}toStr(){return Je(this)}toHex(){return function(t){let e="";for(let r=0;r<t.length;r++)e+=t[r].toString(16).padStart(2,"0");return e}(this)}toBytes(){return new Uint8Array(this)}tob58chk(){return Ce.encode(this)}toBase64(){return ke.encode(this)}toB64url(){return Pe.encode(this)}append(t){return or.join([this,or.bytes(t)])}prepend(t){return or.join([or.bytes(t),this])}reverse(){const t=new Uint8Array(this).reverse();return new or(t)}slice(t,e){const r=new Uint8Array(this).slice(t,e);return new or(r)}set(t,e){this.set(t,e)}subarray(t,e){const r=new Uint8Array(this).subarray(t,e);return new or(r)}write(t,e){const r=or.bytes(t);this.set(r,e)}prefixSize(t){const e=or.varInt(this.length,t);return or.join([e,this])}static from(t){return new or(Uint8Array.from(t))}static of(...t){return new or(Uint8Array.of(...t))}static join(t){const e=er(t.map((t=>or.bytes(t))));return new or(e)}static sort(t,e){const r=t.map((t=>mr(t,e).hex));return r.sort(),r.map((t=>or.hex(t,e)))}static varInt(t,e){if(t<253)return or.num(t,1);if(t<65536)return or.of(253,...or.num(t,2,e));if(t<4294967296)return or.of(254,...or.num(t,4,e));if(BigInt(t)<0x10000000000000000n)return or.of(255,...or.num(t,8,e));throw new Error(`Value is too large: ${t}`)}}function sr(t,e,r){return new or(t,e,r)}function fr(t,e,r){return new or(function(t){const e=t.split("").map(Number);if(e.length%8!=0)throw new Error(`Binary array is invalid length: ${t.length}`);const r=new Uint8Array(e.length/8);for(let t=0,n=0;t<e.length;t+=8,n++){let i=0;for(let r=0;r<8;r++)i|=e[t+r]<<7-r;r[n]=i}return r}(t),e,r)}function ar(t,e,r){return new or(t,e,r)}function cr(t,e,r){return new or(t,e,r)}function hr(t,e,r){return new or(Me(t),e,r)}function ur(t,e,r){return new or(t,e,r)}function dr(t,e){void 0===e&&(e=rr);const r=JSON.stringify(t,e);return new or(Me(r))}function lr(t){return new or(ke.decode(t))}function gr(t){return new or(Pe.decode(t))}function wr(t,e,r){const{bytes:n,prefix:i}=ze.decode(t,e);return"string"==typeof r&&De(i,r),new or(n)}function yr(t,e,r){const{bytes:n,prefix:i}=Fe.decode(t,e);return"string"==typeof r&&De(i,r),new or(n)}function pr(t){return new or(Ce.decode(t))}class br{constructor(t){this.data=or.bytes(t),this.size=this.data.length}peek(t){if(t>this.size)throw new Error(`Size greater than stream: ${t} > ${this.size}`);return new or(this.data.slice(0,t))}read(t){t=t??this.readSize();const e=this.peek(t);return this.data=this.data.slice(t),this.size=this.data.length,e}readSize(t){const e=this.read(1).num;switch(!0){case e>=0&&e<253:return e;case 253===e:return this.read(2).toNum(t);case 254===e:return this.read(4).toNum(t);case 255===e:return this.read(8).toNum(t);default:throw new Error(`Varint is out of range: ${e}`)}}}function mr(t,e,r){return new or(t,e,r)}const xr=BigInt(2**32-1),Er=BigInt(32);function Br(t,e=!1){return e?{h:Number(t&xr),l:Number(t>>Er&xr)}:{h:0|Number(t>>Er&xr),l:0|Number(t&xr)}}var vr={fromBig:Br,split:function(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let i=0;i<t.length;i++){const{h:o,l:s}=Br(t[i],e);[r[i],n[i]]=[o,s]}return[r,n]},toBig:(t,e)=>BigInt(t>>>0)<<Er|BigInt(e>>>0),shrSH:(t,e,r)=>t>>>r,shrSL:(t,e,r)=>t<<32-r|e>>>r,rotrSH:(t,e,r)=>t>>>r|e<<32-r,rotrSL:(t,e,r)=>t<<32-r|e>>>r,rotrBH:(t,e,r)=>t<<64-r|e>>>r-32,rotrBL:(t,e,r)=>t>>>r-32|e<<64-r,rotr32H:(t,e)=>e,rotr32L:(t,e)=>t,rotlSH:(t,e,r)=>t<<r|e>>>32-r,rotlSL:(t,e,r)=>e<<r|t>>>32-r,rotlBH:(t,e,r)=>e<<r-32|t>>>64-r,rotlBL:(t,e,r)=>t<<r-32|e>>>64-r,add:function(t,e,r,n){const i=(e>>>0)+(n>>>0);return{h:t+r+(i/2**32|0)|0,l:0|i}},add3L:(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),add3H:(t,e,r,n)=>e+r+n+(t/2**32|0)|0,add4L:(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),add4H:(t,e,r,n,i)=>e+r+n+i+(t/2**32|0)|0,add5H:(t,e,r,n,i,o)=>e+r+n+i+o+(t/2**32|0)|0,add5L:(t,e,r,n,i)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0)};const[Ar,Ir]=vr.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((t=>BigInt(t)))),Sr=new Uint32Array(80),Ur=new Uint32Array(80);class _r extends l{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:i,Cl:o,Dh:s,Dl:f,Eh:a,El:c,Fh:h,Fl:u,Gh:d,Gl:l,Hh:g,Hl:w}=this;return[t,e,r,n,i,o,s,f,a,c,h,u,d,l,g,w]}set(t,e,r,n,i,o,s,f,a,c,h,u,d,l,g,w){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|o,this.Dh=0|s,this.Dl=0|f,this.Eh=0|a,this.El=0|c,this.Fh=0|h,this.Fl=0|u,this.Gh=0|d,this.Gl=0|l,this.Hh=0|g,this.Hl=0|w}process(t,e){for(let r=0;r<16;r++,e+=4)Sr[r]=t.getUint32(e),Ur[r]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|Sr[t-15],r=0|Ur[t-15],n=vr.rotrSH(e,r,1)^vr.rotrSH(e,r,8)^vr.shrSH(e,r,7),i=vr.rotrSL(e,r,1)^vr.rotrSL(e,r,8)^vr.shrSL(e,r,7),o=0|Sr[t-2],s=0|Ur[t-2],f=vr.rotrSH(o,s,19)^vr.rotrBH(o,s,61)^vr.shrSH(o,s,6),a=vr.rotrSL(o,s,19)^vr.rotrBL(o,s,61)^vr.shrSL(o,s,6),c=vr.add4L(i,a,Ur[t-7],Ur[t-16]),h=vr.add4H(c,n,f,Sr[t-7],Sr[t-16]);Sr[t]=0|h,Ur[t]=0|c}let{Ah:r,Al:n,Bh:i,Bl:o,Ch:s,Cl:f,Dh:a,Dl:c,Eh:h,El:u,Fh:d,Fl:l,Gh:g,Gl:w,Hh:y,Hl:p}=this;for(let t=0;t<80;t++){const e=vr.rotrSH(h,u,14)^vr.rotrSH(h,u,18)^vr.rotrBH(h,u,41),b=vr.rotrSL(h,u,14)^vr.rotrSL(h,u,18)^vr.rotrBL(h,u,41),m=h&d^~h&g,x=u&l^~u&w,E=vr.add5L(p,b,x,Ir[t],Ur[t]),B=vr.add5H(E,y,e,m,Ar[t],Sr[t]),v=0|E,A=vr.rotrSH(r,n,28)^vr.rotrBH(r,n,34)^vr.rotrBH(r,n,39),I=vr.rotrSL(r,n,28)^vr.rotrBL(r,n,34)^vr.rotrBL(r,n,39),S=r&i^r&s^i&s,U=n&o^n&f^o&f;y=0|g,p=0|w,g=0|d,w=0|l,d=0|h,l=0|u,({h:h,l:u}=vr.add(0|a,0|c,0|B,0|v)),a=0|s,c=0|f,s=0|i,f=0|o,i=0|r,o=0|n;const _=vr.add3L(v,I,U);r=vr.add3H(_,B,A,S),n=0|_}({h:r,l:n}=vr.add(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:o}=vr.add(0|this.Bh,0|this.Bl,0|i,0|o)),({h:s,l:f}=vr.add(0|this.Ch,0|this.Cl,0|s,0|f)),({h:a,l:c}=vr.add(0|this.Dh,0|this.Dl,0|a,0|c)),({h:h,l:u}=vr.add(0|this.Eh,0|this.El,0|h,0|u)),({h:d,l:l}=vr.add(0|this.Fh,0|this.Fl,0|d,0|l)),({h:g,l:w}=vr.add(0|this.Gh,0|this.Gl,0|g,0|w)),({h:y,l:p}=vr.add(0|this.Hh,0|this.Hl,0|y,0|p)),this.set(r,n,i,o,s,f,a,c,h,u,d,l,g,w,y,p)}roundClean(){Sr.fill(0),Ur.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Lr extends _r{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class Hr extends _r{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class $r extends _r{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const Nr=u((()=>new _r));u((()=>new Lr)),u((()=>new Hr)),u((()=>new $r));const Tr=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Or=Uint8Array.from({length:16},((t,e)=>e)),Rr=Or.map((t=>(9*t+5)%16));let Cr=[Or],kr=[Rr];for(let t=0;t<4;t++)for(let e of[Cr,kr])e.push(e[t].map((t=>Tr[t])));const Pr=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((t=>new Uint8Array(t))),zr=Cr.map(((t,e)=>t.map((t=>Pr[e][t])))),Fr=kr.map(((t,e)=>t.map((t=>Pr[e][t])))),qr=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),Dr=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),jr=(t,e)=>t<<e|t>>>32-e;function Vr(t,e,r,n){return 0===t?e^r^n:1===t?e&r|~e&n:2===t?(e|~r)^n:3===t?e&n|r&~n:e^(r|~n)}const Gr=new Uint32Array(16);class Wr extends l{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:r,h3:n,h4:i}=this;return[t,e,r,n,i]}set(t,e,r,n,i){this.h0=0|t,this.h1=0|e,this.h2=0|r,this.h3=0|n,this.h4=0|i}process(t,e){for(let r=0;r<16;r++,e+=4)Gr[r]=t.getUint32(e,!0);let r=0|this.h0,n=r,i=0|this.h1,o=i,s=0|this.h2,f=s,a=0|this.h3,c=a,h=0|this.h4,u=h;for(let t=0;t<5;t++){const e=4-t,d=qr[t],l=Dr[t],g=Cr[t],w=kr[t],y=zr[t],p=Fr[t];for(let e=0;e<16;e++){const n=jr(r+Vr(t,i,s,a)+Gr[g[e]]+d,y[e])+h|0;r=h,h=a,a=0|jr(s,10),s=i,i=n}for(let t=0;t<16;t++){const r=jr(n+Vr(e,o,f,c)+Gr[w[t]]+l,p[t])+u|0;n=u,u=c,c=0|jr(f,10),f=o,o=r}}this.set(this.h1+s+c|0,this.h2+a+u|0,this.h3+h+n|0,this.h4+r+o|0,this.h0+i+f|0)}roundClean(){Gr.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const Yr=u((()=>new Wr));function Zr(t){const e=or.bytes(t);return or.raw(x(e))}function Kr(t){const e=or.bytes(t);return or.raw(Nr(e))}function Mr(t){const e=or.bytes(t);return or.raw(Nr(e))}function Jr(t){const e=or.bytes(t);return or.raw(x(x(e)))}function Qr(t){const e=or.bytes(t);return or.raw(Yr(x(e)))}function Xr(t,e){const r=or.bytes(t),n=or.bytes(e);return or.raw(yt(x,r,n))}function tn(t,e){const r=or.bytes(t),n=or.bytes(e);return or.raw(yt(Nr,r,n))}function en(t){const e=or.str(t).digest;return or.join([e,e])}function rn(t,...e){const r=en(t);return or.join([r,...e]).digest}const nn=It.CURVE,on=nn.n,sn=nn.p,fn={x:nn.Gx,y:nn.Gy},an=BigInt(0),cn=BigInt(1),hn=BigInt(2),un=BigInt(3),dn=BigInt(4),ln={N:on,P:sn,G:fn,_0n:an,_1n:cn,_2n:hn,_3n:un,_4n:dn},gn=nt(on,32,!0),wn=t=>M(t,on);var yn=Object.freeze({__proto__:null,CONST:ln,curve:nn,ecc:gn,in_field:t=>"bigint"==typeof t&&an<t&&t<on,invert:X,mod:M,modN:wn,modP:t=>M(t,sn),mod_bytes:function(t){const e=or.bytes(t).big;return or.big(wn(e),32)},on_curve:t=>"bigint"==typeof t&&an<t&&t<sn,pow:J,pow2:Q,powN:(t,e)=>J(t,e,on)});function pn(t){return or.random(t)}function bn(t){const e=or.bytes(t);if(32===e.length)return e;if(33===e.length)return e.slice(1,33);throw new TypeError(`Invalid key length: ${e.length}`)}function mn(t,e=!1){const r=or.bytes(t);if(32===r.length)return r.prepend(2);if(33===r.length)return e&&(r[0]=2),r;throw new TypeError(`Invalid key size: ${r.length}`)}var xn=Object.freeze({__proto__:null,increment_buffer:function(t){let e=t.length-1;for(;e>=0;e--)if(t[e]<255)return t.set([t[e]+1],e),t;throw TypeError("Unable to increment buffer: "+t.toString())},normalize_x:mn,parse_extended_key:function(t){const e=or.b58chk(t).stream,r={prefix:e.read(4).num,depth:e.read(1).num,fprint:e.read(4).num,index:e.read(4).num,code:e.read(32).hex,type:e.read(1).num,key:e.read(32).hex};if(e.size>0)throw new TypeError("Unparsed data remaining in buffer!");return r},parse_x:bn,random:pn});const{_1n:En}=ln,Bn=It.ProjectivePoint,vn=Bn;function An(t){return new Bn(t.x,t.y,En).hasEvenY()}function In(t){return"object"==typeof t&&"bigint"==typeof t.x&&"bigint"==typeof t.y}function Sn(t){if(!In(t))return!1;const e=new Bn(t.x,t.y,En);try{return e.assertValidity(),!0}catch{return!1}}var Un=Object.freeze({__proto__:null,Noble:vn,add:function(t,e){if(null===t)return e;if(null===e)return t;const r=new Bn(t.x,t.y,En),n=new Bn(e.x,e.y,En);try{const t=r.add(n);return t.assertValidity(),{x:t.x,y:t.y}}catch{return null}},eq:function(t,e){return null===t&&null===e||null!==t&&null!==e&&(t.x===e.x&&t.y===e.y)},gen:function(t){const e=or.bytes(t),r=Bn.BASE.multiply(e.big);return r.assertValidity(),{x:r.x,y:r.y}},is_even:An,is_point:In,is_valid:Sn,lift_x:function(t,e=!1){const r=mn(t,e),n=Bn.fromHex(r.hex);return n.assertValidity(),{x:n.x,y:n.y}},mul:function(t,e){if(null===t)return null;try{const r=or.bytes(e),n=new Bn(t.x,t.y,En).multiply(r.big);return n.assertValidity(),{x:n.x,y:n.y}}catch{return null}},negate:function(t){const e=new Bn(t.x,t.y,En);try{const t=e.negate();return t.assertValidity(),{x:t.x,y:t.y}}catch{return null}},sub:function(t,e){if(null===t)return e;if(null===e)return t;const r=new Bn(t.x,t.y,En),n=new Bn(e.x,e.y,En);try{const t=r.subtract(n);return t.assertValidity(),{x:t.x,y:t.y}}catch{return null}},to_bytes:function(t){const e=or.big(t.x,32),r=An(t)?2:3;return or.join([r,e])}});const{N:_n,P:Ln,_0n:Hn}=ln;function $n(t,e=!1){if(e)throw new Error(t);return!1}function Nn(t,e,r){const n=or.bytes(t);return n.length===e||$n(`Invalid byte size: ${n.hex} !== ${e}`,r)}function Tn(t,e){return"bigint"==typeof t&&Hn<t&&t<Ln||$n("x value is not on the curve!",e),!0}function On(t,e){return"bigint"==typeof t&&Hn<t&&t<_n||$n("x value is not in the field!",e),!0}function Rn(t,e){if(void 0===e){if(!t.startsWith("m"))throw new Error("You need to specify a chain-code for a non-root path.")}else if(32!==or.bytes(e).length)throw new Error("Chain code must be 32 bytes!")}function Cn(t){if(null===t.match(/^(m)?(\/)?(\w+'?\/)*\w+'?$/))throw new Error("Provided path string is invalid: "+t)}function kn(t){if(t>2147483648)throw new TypeError("Index value must not exceed 31 bits.")}function Pn(t,e){if(t&&!e)throw new Error("Cannot derive hardedened paths when is_private is false!")}var zn=Object.freeze({__proto__:null,exists:function(t){if(void 0===t)throw new TypeError("Input is undefined!")},fail:$n,in_field:On,min_value:function(t,e){const r=or.bytes(t).big;if(r<e)throw new TypeError(`Bytes integer value is too low: ${r} < ${e}`)},on_curve:Tn,size:Nn,valid_chain:Rn,valid_derive_state:Pn,valid_hash:function(t){if(null===t.match(/^[0-9a-fA-F]{64}$/))throw new Error("Provided hash string is invalid: "+t)},valid_index:kn,valid_path:Cn,valid_point:function(t){if(!Sn(t))throw new TypeError("Point is invalid!")},valid_pubkey:function(t){if(33!==or.bytes(t).length)throw new TypeError("Index value must not exceed 31 bits.")}});const Fn=It.ProjectivePoint;class qn extends Uint8Array{static{this.N=It.CURVE.n}static mod(t){return new qn(t)}static is_valid(t,e){return On(or.bytes(t,32).big,e)}constructor(t){let e=function(t){if(t instanceof qn)return t.big;if(t instanceof Dn)return t.x.big;if(t instanceof Uint8Array)return or.raw(t).big;if("string"==typeof t)return or.hex(t).big;if("number"==typeof t)return or.num(t).big;if("bigint"==typeof t)return BigInt(t);throw TypeError("Invalid input type:"+typeof t)}(t);e=wn(e),qn.is_valid(e,!0),super(or.big(e,32),32)}get buff(){return new or(this)}get raw(){return this.buff.raw}get big(){return this.buff.big}get hex(){return this.buff.hex}get point(){return this.generate()}get hasOddY(){return this.point.hasOddY}get negated(){return this.hasOddY?this.negate():this}gt(t){return new qn(t).big>this.big}lt(t){return new qn(t).big<this.big}eq(t){return new qn(t).big===this.big}ne(t){return new qn(t).big!==this.big}add(t){const e=qn.mod(t),r=gn.add(this.big,e.big);return new qn(r)}sub(t){const e=qn.mod(t),r=gn.sub(this.big,e.big);return new qn(r)}mul(t){const e=qn.mod(t),r=gn.mul(this.big,e.big);return new qn(r)}pow(t){const e=qn.mod(t),r=gn.pow(this.big,e.big);return new qn(r)}div(t){const e=qn.mod(t),r=gn.div(this.big,e.big);return new qn(r)}negate(){return new qn(qn.N-this.big)}generate(){const t=It.ProjectivePoint.BASE.multiply(this.big);return Dn.import(t)}}class Dn{static{this.P=ln.P}static{this.G=new Dn(ln.G.x,ln.G.y)}static{this.curve=It.CURVE}static{this.base=It.ProjectivePoint.BASE}static from_x(t){let e=function(t){if(t instanceof qn)return t.point.buff;if(t instanceof Dn)return t.buff;if(t instanceof Uint8Array||"string"==typeof t)return or.bytes(t);if("number"==typeof t||"bigint"==typeof t)return or.bytes(t,32);throw new TypeError("Unknown type: "+typeof t)}(t);32===e.length&&(e=e.prepend(2)),Nn(e,33);const r=Fn.fromHex(e.hex);return r.assertValidity(),new Dn(r.x,r.y)}static generate(t){const e=qn.mod(t),r=Dn.base.multiply(e.big);return Dn.import(r)}static{this.mul=Dn.generate}static import(t){const e=t instanceof Dn?{x:t.x.big,y:t.y.big}:{x:t.x,y:t.y};return new Dn(e.x,e.y)}constructor(t,e){this._p=new Fn(t,e,1n),this.p.assertValidity()}get p(){return this._p}get x(){return or.big(this.p.x,32)}get y(){return or.big(this.p.y,32)}get buff(){return or.raw(this.p.toRawBytes(!0))}get raw(){return this.buff.raw}get hex(){return this.buff.hex}get hasEvenY(){return this.p.hasEvenY()}get hasOddY(){return!this.p.hasEvenY()}eq(t){const e=t instanceof Dn?t:Dn.from_x(t);return this.x.big===e.x.big&&this.y.big===e.y.big}add(t){return t instanceof Dn?Dn.import(this.p.add(t.p)):Dn.import(this.p.add(Dn.generate(t).p))}sub(t){return t instanceof Dn?Dn.import(this.p.subtract(t.p)):Dn.import(this.p.subtract(Dn.generate(t).p))}mul(t){return t instanceof Dn?Dn.import(this.p.multiply(t.x.big)):Dn.import(this.p.multiply(qn.mod(t).big))}negate(){return Dn.import(this.p.negate())}}function jn(t,e=!1){const r=qn.mod(t);return e?r.negated.buff:r.buff}function Vn(t,e=!1){const r=qn.mod(t).point;return e?r.x:r.buff}function Gn(t,e,r){const n=jn(t,r);return[n,Vn(n,e)]}var Wn=Object.freeze({__proto__:null,gen_keypair:function(t,e){return Gn(pn(32),t,e)},gen_seckey:function(t){return jn(pn(32),t)},get_keypair:Gn,get_pubkey:Vn,get_seckey:jn,is_even_pub:function(t){const e=or.bytes(t);switch(!0){case 32===e.length:case 33===e.length&&2===e[0]:return!0;case 33===e.length&&3===e[0]:return!1;default:throw new TypeError(`Invalid public key: ${e.hex}`)}}});const Yn=/^[0-9]{0,10}$/,Zn=/^[0-9a-zA-Z_&?=]{64}$/;function Kn(t,e){const r=tn(t,e);return[r.slice(0,32),r.slice(32)]}const Mn={aux:or.random(32),throws:!1,xonly:!0},Jn={xonly:!1,even_y:!1,tag:"ecdh/shared"};function Qn(t={}){return{...Mn,...t}}function Xn(t={}){return{...Jn,...t}}function ti(t,e){const r=Dn.from_x(e),n=qn.mod(t);return r.mul(n).buff}function ei(t,e,r){const n=Xn(r),i=jn(t,n.even_y),o=Vn(i,n.xonly),s=en(n.tag),f=or.bytes(e),a=ti(i,f),c=[o.hex,f.hex];if(c.sort(),void 0!==n.aux){const t=or.bytes(n.aux);c.push(t.hex)}return tn(a,or.join([s,...c]))}var ri=Object.freeze({__proto__:null,get_shared_code:ei,get_shared_key:ti});const{_0n:ni}=ln;var ii=Object.freeze({__proto__:null,recover:function(t,e,r,n){const i=or.bytes(t),o=or.bytes(e),s=or.bytes(r),f=rn("BIP0340/nonce",ei(n,r,{tag:"ecdh/recovery"}),e),a=rn("BIP0340/challenge",i.slice(0,32),bn(s),o),c=new qn(a),h=new qn(f).negated;return new qn(i.slice(32,64)).sub(h).div(c).buff},sign:function(t,e,r){const n=Qn(r),{adaptor:i,tweak:o,xonly:s}=n,f=or.bytes(t);let a=qn.mod(e);void 0!==o&&(s&&(a=a.negated),a=a.add(o));const c=a.point,h=s?a.negated.big:a.big,u=function(t,e,r,n){const{aux:i,nonce:o,recovery:s}=Qn(n);let f;if(void 0!==o)f=or.bytes(o);else if(void 0!==s)f=ei(t,s,{tag:"ecdh/recovery"});else{const r=rn("BIP0340/aux",i),n=or.bytes(t).big^r.big;f=or.join([n,e])}return rn("BIP0340/nonce",f,or.bytes(r))}(or.big(h,32),c.x,f,n);let d=qn.mod(u);void 0!==i&&(s&&(d=d.negated),d=d.add(i));const l=d.point,g=s?d.negated.big:d.big,w=rn("BIP0340/challenge",l.x.raw,c.x.raw,f),y=qn.mod(w),p=qn.mod(g+y.big*h),b=s?l.x.raw:l.raw;return or.join([b,p.raw])},verify:function(t,e,r,n){const{throws:i}=Qn(n),o=or.bytes(e),s=or.bytes(t);if(s.length<64)return $n("Signature length is too small: "+String(s.length),i);Nn(r,32);const f=Dn.from_x(r),a=s.subarray(0,32),c=Dn.from_x(a),h=s.subarray(32,64),u=qn.mod(h).point,d=rn("BIP0340/challenge",c.x,f.x,o),l=qn.mod(d),g=f.mul(l.big),w=u.sub(g);return c.hasOddY?$n("Signature R value has odd Y coordinate!",i):c.x.big===ni?$n("Signature R value is infinite!",i):c.x.big!==w.x.big?$n(`Signature is invalid! R: ${c.x.hex} r:${w.x.hex}`,i):c.x.big===w.x.big}});const oi={secp:It,schnorr:jt},si={...Wn,...ii,derive:function(t,e,r,n=!1){Cn(t);const i=t.startsWith("m");Rn(t,r);let o=void 0!==r?or.bytes(r):or.str("Bitcoin seed"),s=or.bytes(e);if(i){const t=Kn(o,s);s=or.raw(t[0]),o=or.raw(t[1]),n=!0}n?Nn(s,32,!0):(33===s.length&&(s=s.slice(1)),Nn(s,33));const f=function(t){const e=[];let r=t.split("/");"m"!==r[0]&&""!==r[0]||(r=r.slice(1));for(let t of r){let r=!1;if("'"===t.slice(-1)&&(r=!0,t=t.slice(0,-1)),null!==t.match(Yn)){let n=parseInt(t,10);kn(n),r&&(n+=2147483648),e.push([or.num(n,4),r])}else{if(null===t.match(Zn))throw new Error("Invalid path segment:"+t);{let n=or.str(t);r&&(n=n.prepend(128)),e.push([n.digest,r])}}}return e}(t);for(const t of f){const[e,r]=t;Pn(r,n);const i=r?or.join([0,s,e]):or.join([Vn(s),e]),[f,a]=Kn(o,i);o=or.raw(a),n?(s=qn.mod(s).add(f).buff,On(s.big,!0)):(s=Dn.from_x(s).add(f).buff,Tn(s.slice(1).big))}return[s,o]},parse_x:bn,normalize_x:mn};return t.Field=qn,t.Point=Dn,t.assert=zn,t.code_config=Xn,t.digest=rn,t.ecc=si,t.ecdh=ri,t.hash=function(t,e="sha256"){switch(e){case"sha256":return Zr(t);case"sha512":return Kr(t);case"hash256":return Jr(t);case"ripe160":return Mr(t);case"hash160":return Qr(t);default:throw new Error("Unrecognized format:"+String(e))}},t.hash160=Qr,t.hash256=Jr,t.hmac=function(t,e,r="hmac256"){switch(r){case"hmac256":return Xr(t,e);case"hmac512":return tn(t,e);default:throw new Error("Unrecognized format:"+String(r))}},t.hmac256=Xr,t.hmac512=tn,t.math=yn,t.noble=oi,t.point=Un,t.ripe160=Mr,t.sha256=Zr,t.sha512=Kr,t.sign_config=Qn,t.taghash=en,t.util=xn,t}({});
//# sourceMappingURL=browser.js.map
